// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use hinoko_sys;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum FwIsoCtxError {
    Failed,
    Allocated,
    NotAllocated,
    Mapped,
    NotMapped,
    ChunkUnregistered,
    NoIsocChannel,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FwIsoCtxError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "FwIsoCtxError::{}", match *self {
            FwIsoCtxError::Failed => "Failed",
            FwIsoCtxError::Allocated => "Allocated",
            FwIsoCtxError::NotAllocated => "NotAllocated",
            FwIsoCtxError::Mapped => "Mapped",
            FwIsoCtxError::NotMapped => "NotMapped",
            FwIsoCtxError::ChunkUnregistered => "ChunkUnregistered",
            FwIsoCtxError::NoIsocChannel => "NoIsocChannel",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for FwIsoCtxError {
    type GlibType = hinoko_sys::HinokoFwIsoCtxError;

    fn to_glib(&self) -> hinoko_sys::HinokoFwIsoCtxError {
        match *self {
            FwIsoCtxError::Failed => hinoko_sys::HINOKO_FW_ISO_CTX_ERROR_FAILED,
            FwIsoCtxError::Allocated => hinoko_sys::HINOKO_FW_ISO_CTX_ERROR_ALLOCATED,
            FwIsoCtxError::NotAllocated => hinoko_sys::HINOKO_FW_ISO_CTX_ERROR_NOT_ALLOCATED,
            FwIsoCtxError::Mapped => hinoko_sys::HINOKO_FW_ISO_CTX_ERROR_MAPPED,
            FwIsoCtxError::NotMapped => hinoko_sys::HINOKO_FW_ISO_CTX_ERROR_NOT_MAPPED,
            FwIsoCtxError::ChunkUnregistered => hinoko_sys::HINOKO_FW_ISO_CTX_ERROR_CHUNK_UNREGISTERED,
            FwIsoCtxError::NoIsocChannel => hinoko_sys::HINOKO_FW_ISO_CTX_ERROR_NO_ISOC_CHANNEL,
            FwIsoCtxError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<hinoko_sys::HinokoFwIsoCtxError> for FwIsoCtxError {
    fn from_glib(value: hinoko_sys::HinokoFwIsoCtxError) -> Self {
        match value {
            0 => FwIsoCtxError::Failed,
            1 => FwIsoCtxError::Allocated,
            2 => FwIsoCtxError::NotAllocated,
            3 => FwIsoCtxError::Mapped,
            4 => FwIsoCtxError::NotMapped,
            5 => FwIsoCtxError::ChunkUnregistered,
            6 => FwIsoCtxError::NoIsocChannel,
            value => FwIsoCtxError::__Unknown(value),
        }
    }
}

impl ErrorDomain for FwIsoCtxError {
    fn domain() -> Quark {
        unsafe { from_glib(hinoko_sys::hinoko_fw_iso_ctx_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(FwIsoCtxError::Failed),
            1 => Some(FwIsoCtxError::Allocated),
            2 => Some(FwIsoCtxError::NotAllocated),
            3 => Some(FwIsoCtxError::Mapped),
            4 => Some(FwIsoCtxError::NotMapped),
            5 => Some(FwIsoCtxError::ChunkUnregistered),
            6 => Some(FwIsoCtxError::NoIsocChannel),
            _ => Some(FwIsoCtxError::Failed),
        }
    }
}

impl StaticType for FwIsoCtxError {
    fn static_type() -> Type {
        unsafe { from_glib(hinoko_sys::hinoko_fw_iso_ctx_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FwIsoCtxError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FwIsoCtxError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FwIsoCtxError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum FwIsoCtxMode {
    Tx,
    RxSingle,
    RxMultiple,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FwIsoCtxMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "FwIsoCtxMode::{}", match *self {
            FwIsoCtxMode::Tx => "Tx",
            FwIsoCtxMode::RxSingle => "RxSingle",
            FwIsoCtxMode::RxMultiple => "RxMultiple",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for FwIsoCtxMode {
    type GlibType = hinoko_sys::HinokoFwIsoCtxMode;

    fn to_glib(&self) -> hinoko_sys::HinokoFwIsoCtxMode {
        match *self {
            FwIsoCtxMode::Tx => hinoko_sys::HINOKO_FW_ISO_CTX_MODE_TX,
            FwIsoCtxMode::RxSingle => hinoko_sys::HINOKO_FW_ISO_CTX_MODE_RX_SINGLE,
            FwIsoCtxMode::RxMultiple => hinoko_sys::HINOKO_FW_ISO_CTX_MODE_RX_MULTIPLE,
            FwIsoCtxMode::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<hinoko_sys::HinokoFwIsoCtxMode> for FwIsoCtxMode {
    fn from_glib(value: hinoko_sys::HinokoFwIsoCtxMode) -> Self {
        match value {
            0 => FwIsoCtxMode::Tx,
            1 => FwIsoCtxMode::RxSingle,
            2 => FwIsoCtxMode::RxMultiple,
            value => FwIsoCtxMode::__Unknown(value),
        }
    }
}

impl StaticType for FwIsoCtxMode {
    fn static_type() -> Type {
        unsafe { from_glib(hinoko_sys::hinoko_fw_iso_ctx_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FwIsoCtxMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FwIsoCtxMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FwIsoCtxMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum FwIsoResourceAutoError {
    Failed,
    Allocated,
    NotAllocated,
    Timeout,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FwIsoResourceAutoError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "FwIsoResourceAutoError::{}", match *self {
            FwIsoResourceAutoError::Failed => "Failed",
            FwIsoResourceAutoError::Allocated => "Allocated",
            FwIsoResourceAutoError::NotAllocated => "NotAllocated",
            FwIsoResourceAutoError::Timeout => "Timeout",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for FwIsoResourceAutoError {
    type GlibType = hinoko_sys::HinokoFwIsoResourceAutoError;

    fn to_glib(&self) -> hinoko_sys::HinokoFwIsoResourceAutoError {
        match *self {
            FwIsoResourceAutoError::Failed => hinoko_sys::HINOKO_FW_ISO_RESOURCE_AUTO_ERROR_FAILED,
            FwIsoResourceAutoError::Allocated => hinoko_sys::HINOKO_FW_ISO_RESOURCE_AUTO_ERROR_ALLOCATED,
            FwIsoResourceAutoError::NotAllocated => hinoko_sys::HINOKO_FW_ISO_RESOURCE_AUTO_ERROR_NOT_ALLOCATED,
            FwIsoResourceAutoError::Timeout => hinoko_sys::HINOKO_FW_ISO_RESOURCE_AUTO_ERROR_TIMEOUT,
            FwIsoResourceAutoError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<hinoko_sys::HinokoFwIsoResourceAutoError> for FwIsoResourceAutoError {
    fn from_glib(value: hinoko_sys::HinokoFwIsoResourceAutoError) -> Self {
        match value {
            0 => FwIsoResourceAutoError::Failed,
            1 => FwIsoResourceAutoError::Allocated,
            2 => FwIsoResourceAutoError::NotAllocated,
            3 => FwIsoResourceAutoError::Timeout,
            value => FwIsoResourceAutoError::__Unknown(value),
        }
    }
}

impl ErrorDomain for FwIsoResourceAutoError {
    fn domain() -> Quark {
        unsafe { from_glib(hinoko_sys::hinoko_fw_iso_resource_auto_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(FwIsoResourceAutoError::Failed),
            1 => Some(FwIsoResourceAutoError::Allocated),
            2 => Some(FwIsoResourceAutoError::NotAllocated),
            3 => Some(FwIsoResourceAutoError::Timeout),
            _ => Some(FwIsoResourceAutoError::Failed),
        }
    }
}

impl StaticType for FwIsoResourceAutoError {
    fn static_type() -> Type {
        unsafe { from_glib(hinoko_sys::hinoko_fw_iso_resource_auto_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FwIsoResourceAutoError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FwIsoResourceAutoError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FwIsoResourceAutoError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum FwIsoResourceError {
    Failed,
    Opened,
    NotOpened,
    Timeout,
    Event,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FwIsoResourceError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "FwIsoResourceError::{}", match *self {
            FwIsoResourceError::Failed => "Failed",
            FwIsoResourceError::Opened => "Opened",
            FwIsoResourceError::NotOpened => "NotOpened",
            FwIsoResourceError::Timeout => "Timeout",
            FwIsoResourceError::Event => "Event",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for FwIsoResourceError {
    type GlibType = hinoko_sys::HinokoFwIsoResourceError;

    fn to_glib(&self) -> hinoko_sys::HinokoFwIsoResourceError {
        match *self {
            FwIsoResourceError::Failed => hinoko_sys::HINOKO_FW_ISO_RESOURCE_ERROR_FAILED,
            FwIsoResourceError::Opened => hinoko_sys::HINOKO_FW_ISO_RESOURCE_ERROR_OPENED,
            FwIsoResourceError::NotOpened => hinoko_sys::HINOKO_FW_ISO_RESOURCE_ERROR_NOT_OPENED,
            FwIsoResourceError::Timeout => hinoko_sys::HINOKO_FW_ISO_RESOURCE_ERROR_TIMEOUT,
            FwIsoResourceError::Event => hinoko_sys::HINOKO_FW_ISO_RESOURCE_ERROR_EVENT,
            FwIsoResourceError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<hinoko_sys::HinokoFwIsoResourceError> for FwIsoResourceError {
    fn from_glib(value: hinoko_sys::HinokoFwIsoResourceError) -> Self {
        match value {
            0 => FwIsoResourceError::Failed,
            1 => FwIsoResourceError::Opened,
            2 => FwIsoResourceError::NotOpened,
            3 => FwIsoResourceError::Timeout,
            4 => FwIsoResourceError::Event,
            value => FwIsoResourceError::__Unknown(value),
        }
    }
}

impl ErrorDomain for FwIsoResourceError {
    fn domain() -> Quark {
        unsafe { from_glib(hinoko_sys::hinoko_fw_iso_resource_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(FwIsoResourceError::Failed),
            1 => Some(FwIsoResourceError::Opened),
            2 => Some(FwIsoResourceError::NotOpened),
            3 => Some(FwIsoResourceError::Timeout),
            4 => Some(FwIsoResourceError::Event),
            _ => Some(FwIsoResourceError::Failed),
        }
    }
}

impl StaticType for FwIsoResourceError {
    fn static_type() -> Type {
        unsafe { from_glib(hinoko_sys::hinoko_fw_iso_resource_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FwIsoResourceError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FwIsoResourceError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FwIsoResourceError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum FwScode {
    S100,
    S200,
    S400,
    S800,
    S1600,
    S3200,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FwScode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "FwScode::{}", match *self {
            FwScode::S100 => "S100",
            FwScode::S200 => "S200",
            FwScode::S400 => "S400",
            FwScode::S800 => "S800",
            FwScode::S1600 => "S1600",
            FwScode::S3200 => "S3200",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for FwScode {
    type GlibType = hinoko_sys::HinokoFwScode;

    fn to_glib(&self) -> hinoko_sys::HinokoFwScode {
        match *self {
            FwScode::S100 => hinoko_sys::HINOKO_FW_SCODE_S100,
            FwScode::S200 => hinoko_sys::HINOKO_FW_SCODE_S200,
            FwScode::S400 => hinoko_sys::HINOKO_FW_SCODE_S400,
            FwScode::S800 => hinoko_sys::HINOKO_FW_SCODE_S800,
            FwScode::S1600 => hinoko_sys::HINOKO_FW_SCODE_S1600,
            FwScode::S3200 => hinoko_sys::HINOKO_FW_SCODE_S3200,
            FwScode::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<hinoko_sys::HinokoFwScode> for FwScode {
    fn from_glib(value: hinoko_sys::HinokoFwScode) -> Self {
        match value {
            0 => FwScode::S100,
            1 => FwScode::S200,
            2 => FwScode::S400,
            3 => FwScode::S800,
            4 => FwScode::S1600,
            5 => FwScode::S3200,
            value => FwScode::__Unknown(value),
        }
    }
}

impl StaticType for FwScode {
    fn static_type() -> Type {
        unsafe { from_glib(hinoko_sys::hinoko_fw_scode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FwScode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FwScode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FwScode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

