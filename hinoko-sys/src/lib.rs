// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal)]

extern crate libc;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type HinokoFwIsoCtxError = c_int;
pub const HINOKO_FW_ISO_CTX_ERROR_FAILED: HinokoFwIsoCtxError = 0;
pub const HINOKO_FW_ISO_CTX_ERROR_ALLOCATED: HinokoFwIsoCtxError = 1;
pub const HINOKO_FW_ISO_CTX_ERROR_NOT_ALLOCATED: HinokoFwIsoCtxError = 2;
pub const HINOKO_FW_ISO_CTX_ERROR_MAPPED: HinokoFwIsoCtxError = 3;
pub const HINOKO_FW_ISO_CTX_ERROR_NOT_MAPPED: HinokoFwIsoCtxError = 4;
pub const HINOKO_FW_ISO_CTX_ERROR_CHUNK_UNREGISTERED: HinokoFwIsoCtxError = 5;
pub const HINOKO_FW_ISO_CTX_ERROR_NO_ISOC_CHANNEL: HinokoFwIsoCtxError = 6;

pub type HinokoFwIsoCtxMode = c_int;
pub const HINOKO_FW_ISO_CTX_MODE_TX: HinokoFwIsoCtxMode = 0;
pub const HINOKO_FW_ISO_CTX_MODE_RX_SINGLE: HinokoFwIsoCtxMode = 1;
pub const HINOKO_FW_ISO_CTX_MODE_RX_MULTIPLE: HinokoFwIsoCtxMode = 2;

pub type HinokoFwIsoResourceAutoError = c_int;
pub const HINOKO_FW_ISO_RESOURCE_AUTO_ERROR_FAILED: HinokoFwIsoResourceAutoError = 0;
pub const HINOKO_FW_ISO_RESOURCE_AUTO_ERROR_ALLOCATED: HinokoFwIsoResourceAutoError = 1;
pub const HINOKO_FW_ISO_RESOURCE_AUTO_ERROR_NOT_ALLOCATED: HinokoFwIsoResourceAutoError = 2;
pub const HINOKO_FW_ISO_RESOURCE_AUTO_ERROR_TIMEOUT: HinokoFwIsoResourceAutoError = 3;

pub type HinokoFwIsoResourceError = c_int;
pub const HINOKO_FW_ISO_RESOURCE_ERROR_FAILED: HinokoFwIsoResourceError = 0;
pub const HINOKO_FW_ISO_RESOURCE_ERROR_OPENED: HinokoFwIsoResourceError = 1;
pub const HINOKO_FW_ISO_RESOURCE_ERROR_NOT_OPENED: HinokoFwIsoResourceError = 2;
pub const HINOKO_FW_ISO_RESOURCE_ERROR_TIMEOUT: HinokoFwIsoResourceError = 3;
pub const HINOKO_FW_ISO_RESOURCE_ERROR_EVENT: HinokoFwIsoResourceError = 4;

pub type HinokoFwScode = c_int;
pub const HINOKO_FW_SCODE_S100: HinokoFwScode = 0;
pub const HINOKO_FW_SCODE_S200: HinokoFwScode = 1;
pub const HINOKO_FW_SCODE_S400: HinokoFwScode = 2;
pub const HINOKO_FW_SCODE_S800: HinokoFwScode = 3;
pub const HINOKO_FW_SCODE_S1600: HinokoFwScode = 4;
pub const HINOKO_FW_SCODE_S3200: HinokoFwScode = 5;

// Flags
pub type HinokoFwIsoCtxMatchFlag = c_uint;
pub const HINOKO_FW_ISO_CTX_MATCH_FLAG_TAG0: HinokoFwIsoCtxMatchFlag = 1;
pub const HINOKO_FW_ISO_CTX_MATCH_FLAG_TAG1: HinokoFwIsoCtxMatchFlag = 2;
pub const HINOKO_FW_ISO_CTX_MATCH_FLAG_TAG2: HinokoFwIsoCtxMatchFlag = 4;
pub const HINOKO_FW_ISO_CTX_MATCH_FLAG_TAG3: HinokoFwIsoCtxMatchFlag = 8;

// Records
#[repr(C)]
pub struct HinokoCycleTimer(c_void);

impl ::std::fmt::Debug for HinokoCycleTimer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HinokoCycleTimer @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HinokoFwIsoCtxClass {
    pub parent_class: gobject::GObjectClass,
    pub stopped: Option<unsafe extern "C" fn(*mut HinokoFwIsoCtx, *mut glib::GError)>,
}

impl ::std::fmt::Debug for HinokoFwIsoCtxClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HinokoFwIsoCtxClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("stopped", &self.stopped)
         .finish()
    }
}

#[repr(C)]
pub struct _HinokoFwIsoCtxPrivate(c_void);

pub type HinokoFwIsoCtxPrivate = *mut _HinokoFwIsoCtxPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HinokoFwIsoResourceAutoClass {
    pub parent_class: HinokoFwIsoResourceClass,
}

impl ::std::fmt::Debug for HinokoFwIsoResourceAutoClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HinokoFwIsoResourceAutoClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _HinokoFwIsoResourceAutoPrivate(c_void);

pub type HinokoFwIsoResourceAutoPrivate = *mut _HinokoFwIsoResourceAutoPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HinokoFwIsoResourceClass {
    pub parent_class: gobject::GObjectClass,
    pub allocated: Option<unsafe extern "C" fn(*mut HinokoFwIsoResource, c_uint, c_uint, *mut glib::GError)>,
    pub deallocated: Option<unsafe extern "C" fn(*mut HinokoFwIsoResource, c_uint, c_uint, *mut glib::GError)>,
}

impl ::std::fmt::Debug for HinokoFwIsoResourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HinokoFwIsoResourceClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("allocated", &self.allocated)
         .field("deallocated", &self.deallocated)
         .finish()
    }
}

#[repr(C)]
pub struct _HinokoFwIsoResourcePrivate(c_void);

pub type HinokoFwIsoResourcePrivate = *mut _HinokoFwIsoResourcePrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HinokoFwIsoRxMultipleClass {
    pub parent_class: HinokoFwIsoCtxClass,
    pub interrupted: Option<unsafe extern "C" fn(*mut HinokoFwIsoRxMultiple, c_uint)>,
}

impl ::std::fmt::Debug for HinokoFwIsoRxMultipleClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HinokoFwIsoRxMultipleClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("interrupted", &self.interrupted)
         .finish()
    }
}

#[repr(C)]
pub struct _HinokoFwIsoRxMultiplePrivate(c_void);

pub type HinokoFwIsoRxMultiplePrivate = *mut _HinokoFwIsoRxMultiplePrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HinokoFwIsoRxSingleClass {
    pub parent_class: HinokoFwIsoCtxClass,
    pub interrupted: Option<unsafe extern "C" fn(*mut HinokoFwIsoRxSingle, c_uint, c_uint, *const u8, c_uint, c_uint)>,
}

impl ::std::fmt::Debug for HinokoFwIsoRxSingleClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HinokoFwIsoRxSingleClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("interrupted", &self.interrupted)
         .finish()
    }
}

#[repr(C)]
pub struct _HinokoFwIsoRxSinglePrivate(c_void);

pub type HinokoFwIsoRxSinglePrivate = *mut _HinokoFwIsoRxSinglePrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HinokoFwIsoTxClass {
    pub parent_class: HinokoFwIsoCtxClass,
    pub interrupted: Option<unsafe extern "C" fn(*mut HinokoFwIsoTx, c_uint, c_uint, *const u8, c_uint, c_uint)>,
}

impl ::std::fmt::Debug for HinokoFwIsoTxClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HinokoFwIsoTxClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("interrupted", &self.interrupted)
         .finish()
    }
}

#[repr(C)]
pub struct _HinokoFwIsoTxPrivate(c_void);

pub type HinokoFwIsoTxPrivate = *mut _HinokoFwIsoTxPrivate;

// Classes
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HinokoFwIsoCtx {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut HinokoFwIsoCtxPrivate,
}

impl ::std::fmt::Debug for HinokoFwIsoCtx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HinokoFwIsoCtx @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .field("priv_", &self.priv_)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HinokoFwIsoResource {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut HinokoFwIsoResourcePrivate,
}

impl ::std::fmt::Debug for HinokoFwIsoResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HinokoFwIsoResource @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .field("priv_", &self.priv_)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HinokoFwIsoResourceAuto {
    pub parent_instance: HinokoFwIsoResource,
    pub priv_: *mut HinokoFwIsoResourceAutoPrivate,
}

impl ::std::fmt::Debug for HinokoFwIsoResourceAuto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HinokoFwIsoResourceAuto @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .field("priv_", &self.priv_)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HinokoFwIsoRxMultiple {
    pub parent_instance: HinokoFwIsoCtx,
    pub priv_: *mut HinokoFwIsoRxMultiplePrivate,
}

impl ::std::fmt::Debug for HinokoFwIsoRxMultiple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HinokoFwIsoRxMultiple @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .field("priv_", &self.priv_)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HinokoFwIsoRxSingle {
    pub parent_instance: HinokoFwIsoCtx,
    pub priv_: *mut HinokoFwIsoRxSinglePrivate,
}

impl ::std::fmt::Debug for HinokoFwIsoRxSingle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HinokoFwIsoRxSingle @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .field("priv_", &self.priv_)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HinokoFwIsoTx {
    pub parent_instance: HinokoFwIsoCtx,
    pub priv_: *mut HinokoFwIsoTxPrivate,
}

impl ::std::fmt::Debug for HinokoFwIsoTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HinokoFwIsoTx @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .field("priv_", &self.priv_)
         .finish()
    }
}

extern "C" {

    //=========================================================================
    // HinokoFwIsoCtxError
    //=========================================================================
    pub fn hinoko_fw_iso_ctx_error_get_type() -> GType;
    pub fn hinoko_fw_iso_ctx_error_quark() -> glib::GQuark;

    //=========================================================================
    // HinokoFwIsoCtxMode
    //=========================================================================
    pub fn hinoko_fw_iso_ctx_mode_get_type() -> GType;

    //=========================================================================
    // HinokoFwIsoResourceAutoError
    //=========================================================================
    pub fn hinoko_fw_iso_resource_auto_error_get_type() -> GType;
    pub fn hinoko_fw_iso_resource_auto_error_quark() -> glib::GQuark;

    //=========================================================================
    // HinokoFwIsoResourceError
    //=========================================================================
    pub fn hinoko_fw_iso_resource_error_get_type() -> GType;
    pub fn hinoko_fw_iso_resource_error_quark() -> glib::GQuark;

    //=========================================================================
    // HinokoFwScode
    //=========================================================================
    pub fn hinoko_fw_scode_get_type() -> GType;

    //=========================================================================
    // HinokoFwIsoCtxMatchFlag
    //=========================================================================
    pub fn hinoko_fw_iso_ctx_match_flag_get_type() -> GType;

    //=========================================================================
    // HinokoCycleTimer
    //=========================================================================
    pub fn hinoko_cycle_timer_get_type() -> GType;
    pub fn hinoko_cycle_timer_new() -> *mut HinokoCycleTimer;
    pub fn hinoko_cycle_timer_get_clock_id(self_: *mut HinokoCycleTimer, clock_id: *mut c_int);
    pub fn hinoko_cycle_timer_get_cycle_timer(self_: *mut HinokoCycleTimer, cycle_timer: *mut [u16; 3]);
    pub fn hinoko_cycle_timer_get_timestamp(self_: *mut HinokoCycleTimer, tv_sec: *mut i64, tv_nsec: *mut i32);

    //=========================================================================
    // HinokoFwIsoCtx
    //=========================================================================
    pub fn hinoko_fw_iso_ctx_get_type() -> GType;
    pub fn hinoko_fw_iso_ctx_create_source(self_: *mut HinokoFwIsoCtx, gsrc: *mut *mut glib::GSource, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_ctx_get_cycle_timer(self_: *mut HinokoFwIsoCtx, clock_id: c_int, cycle_timer: *const *mut HinokoCycleTimer, error: *mut *mut glib::GError);

    //=========================================================================
    // HinokoFwIsoResource
    //=========================================================================
    pub fn hinoko_fw_iso_resource_get_type() -> GType;
    pub fn hinoko_fw_iso_resource_new() -> *mut HinokoFwIsoResource;
    pub fn hinoko_fw_iso_resource_calculate_bandwidth(bytes_per_payload: c_uint, scode: HinokoFwScode) -> c_uint;
    pub fn hinoko_fw_iso_resource_allocate_once_async(self_: *mut HinokoFwIsoResource, channel_candidates: *mut u8, channel_candidates_count: size_t, bandwidth: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_resource_allocate_once_sync(self_: *mut HinokoFwIsoResource, channel_candidates: *mut u8, channel_candidates_count: size_t, bandwidth: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_resource_create_source(self_: *mut HinokoFwIsoResource, gsrc: *mut *mut glib::GSource, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_resource_deallocate_once_async(self_: *mut HinokoFwIsoResource, channel: c_uint, bandwidth: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_resource_deallocate_once_sync(self_: *mut HinokoFwIsoResource, channel: c_uint, bandwidth: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_resource_open(self_: *mut HinokoFwIsoResource, path: *const c_char, open_flag: c_int, error: *mut *mut glib::GError);

    //=========================================================================
    // HinokoFwIsoResourceAuto
    //=========================================================================
    pub fn hinoko_fw_iso_resource_auto_get_type() -> GType;
    pub fn hinoko_fw_iso_resource_auto_new() -> *mut HinokoFwIsoResourceAuto;
    pub fn hinoko_fw_iso_resource_auto_allocate_async(self_: *mut HinokoFwIsoResourceAuto, channel_candidates: *mut u8, channel_candidates_count: size_t, bandwidth: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_resource_auto_allocate_sync(self_: *mut HinokoFwIsoResourceAuto, channel_candidates: *mut u8, channel_candidates_count: size_t, bandwidth: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_resource_auto_deallocate_async(self_: *mut HinokoFwIsoResourceAuto, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_resource_auto_deallocate_sync(self_: *mut HinokoFwIsoResourceAuto, error: *mut *mut glib::GError);

    //=========================================================================
    // HinokoFwIsoRxMultiple
    //=========================================================================
    pub fn hinoko_fw_iso_rx_multiple_get_type() -> GType;
    pub fn hinoko_fw_iso_rx_multiple_new() -> *mut HinokoFwIsoRxMultiple;
    pub fn hinoko_fw_iso_rx_multiple_allocate(self_: *mut HinokoFwIsoRxMultiple, path: *const c_char, channels: *const u8, channels_length: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_rx_multiple_get_payload(self_: *mut HinokoFwIsoRxMultiple, index: c_uint, payload: *mut *const u8, length: *mut c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_rx_multiple_map_buffer(self_: *mut HinokoFwIsoRxMultiple, bytes_per_chunk: c_uint, chunks_per_buffer: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_rx_multiple_release(self_: *mut HinokoFwIsoRxMultiple);
    pub fn hinoko_fw_iso_rx_multiple_start(self_: *mut HinokoFwIsoRxMultiple, cycle_match: *const [u16; 2], sync: u32, tags: HinokoFwIsoCtxMatchFlag, chunks_per_irq: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_rx_multiple_stop(self_: *mut HinokoFwIsoRxMultiple);
    pub fn hinoko_fw_iso_rx_multiple_unmap_buffer(self_: *mut HinokoFwIsoRxMultiple);

    //=========================================================================
    // HinokoFwIsoRxSingle
    //=========================================================================
    pub fn hinoko_fw_iso_rx_single_get_type() -> GType;
    pub fn hinoko_fw_iso_rx_single_new() -> *mut HinokoFwIsoRxSingle;
    pub fn hinoko_fw_iso_rx_single_allocate(self_: *mut HinokoFwIsoRxSingle, path: *const c_char, channel: c_uint, header_size: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_rx_single_get_payload(self_: *mut HinokoFwIsoRxSingle, index: c_uint, payload: *mut *const u8, length: *mut c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_rx_single_map_buffer(self_: *mut HinokoFwIsoRxSingle, maximum_bytes_per_payload: c_uint, payloads_per_buffer: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_rx_single_release(self_: *mut HinokoFwIsoRxSingle);
    pub fn hinoko_fw_iso_rx_single_start(self_: *mut HinokoFwIsoRxSingle, cycle_match: *const [u16; 2], sync: u32, tags: HinokoFwIsoCtxMatchFlag, packets_per_irq: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_rx_single_stop(self_: *mut HinokoFwIsoRxSingle);
    pub fn hinoko_fw_iso_rx_single_unmap_buffer(self_: *mut HinokoFwIsoRxSingle);

    //=========================================================================
    // HinokoFwIsoTx
    //=========================================================================
    pub fn hinoko_fw_iso_tx_get_type() -> GType;
    pub fn hinoko_fw_iso_tx_new() -> *mut HinokoFwIsoTx;
    pub fn hinoko_fw_iso_tx_allocate(self_: *mut HinokoFwIsoTx, path: *const c_char, scode: HinokoFwScode, channel: c_uint, header_size: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_tx_map_buffer(self_: *mut HinokoFwIsoTx, maximum_bytes_per_payload: c_uint, payloads_per_buffer: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_tx_register_packet(self_: *mut HinokoFwIsoTx, tags: HinokoFwIsoCtxMatchFlag, sy: c_uint, header: *const u8, header_length: c_uint, payload: *const u8, payload_length: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_tx_release(self_: *mut HinokoFwIsoTx);
    pub fn hinoko_fw_iso_tx_start(self_: *mut HinokoFwIsoTx, cycle_match: *const [u16; 2], packets_per_irq: c_uint, error: *mut *mut glib::GError);
    pub fn hinoko_fw_iso_tx_stop(self_: *mut HinokoFwIsoTx);
    pub fn hinoko_fw_iso_tx_unmap_buffer(self_: *mut HinokoFwIsoTx);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn hinoko_sigs_marshal_VOID__UINT_UINT_OBJECT(closure: *mut gobject::GClosure, return_value: *mut gobject::GValue, n_param_values: c_uint, param_values: *const gobject::GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn hinoko_sigs_marshal_VOID__UINT_UINT_POINTER_UINT_UINT(closure: *mut gobject::GClosure, return_value: *mut gobject::GValue, n_param_values: c_uint, param_values: *const gobject::GValue, invocation_hint: gpointer, marshal_data: gpointer);

}
